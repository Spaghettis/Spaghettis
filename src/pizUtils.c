
/* 
    Copyright (c) 2014, Nicolas Danet, < nicolas.danet@free.fr >. 
*/

/* < http://opensource.org/licenses/MIT > */

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

#include "pizUtils.h"

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

/* < http://graphics.stanford.edu/~seander/bithacks.html > */
/* < http://aggregate.org/MAGIC/ > */

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

/* Use intrinsics? */

/* < http://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html > */

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

/* < http://stackoverflow.com/questions/11376288/fast-computing-of-log2-for-64-bit-integers > */
/* < http://hackage.haskell.org/package/bits-0.3.3/src/cbits/debruijn.c > */
/* < http://hackage.haskell.org/package/bits-0.3.3/docs/src/Data-Bits-Extras.html > */
/* < http://llvm.org/docs/doxygen/html/MathExtras_8h_source.html > */

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

static const long pizUtilsDeBruijn32[] = 
    {   
        0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30,
        8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31   
    };

static const long pizUtilsDeBruijn64[] = 
    {
        63, 0, 58, 1, 59, 47, 53, 2, 60, 39, 48, 27, 54, 33, 42, 3,
        61, 51, 37, 40, 49, 18, 28, 20, 55, 30, 34, 11, 43, 14, 22, 4,
        62, 57, 46, 52, 38, 26, 32, 41, 50, 36, 17, 19, 29, 10, 13, 21,
        56, 45, 25, 31, 35, 16, 9, 12, 44, 24, 15, 8, 23, 7, 6, 5
    };

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

uint8_t pizUInt8Reversed (uint8_t v)
{
    return (v * 0x0202020202ULL & 0x010884422010ULL) % 1023;
}

uint16_t pizUInt16Reversed (uint16_t v)
{
    uint8_t hi = (uint8_t)(v >> 8);
    uint8_t lo = (uint8_t)(v & 0xff);
        
    return (((uint16_t)(pizUInt8Reversed (lo))) << 8) | (uint16_t)(pizUInt8Reversed (hi));
}

uint32_t pizUInt32Reversed (uint32_t v)
{
    v = (((v & 0xaaaaaaaa) >> 1) | ((v & 0x55555555) << 1));
    v = (((v & 0xcccccccc) >> 2) | ((v & 0x33333333) << 2));
    v = (((v & 0xf0f0f0f0) >> 4) | ((v & 0x0f0f0f0f) << 4));
    v = (((v & 0xff00ff00) >> 8) | ((v & 0x00ff00ff) << 8));
    
    return ((v >> 16) | (v << 16));
}

uint64_t pizUInt64Reversed (uint64_t v)
{
    uint32_t hi = (uint32_t)(v >> 32);
    uint32_t lo = (uint32_t)(v & 0xffffffffULL);
    
    return ((((uint64_t)pizUInt32Reversed (lo)) << 32) | (uint64_t)(pizUInt32Reversed (hi)));
}

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

int pizUInt32IsPower2 (uint32_t v)
{
    return !(v & (v - 1));
}

int pizUInt64IsPower2 (uint64_t v)
{
    return !(v & (v - 1));
}

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

long pizUInt32LogBase2Index (uint32_t v)
{
    if (!v) { return 0; }
    else {
    //
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    
    return (pizUtilsDeBruijn32[(uint32_t)(v * 0x07c4acddU) >> 27]);
    //
    }
}

long pizUInt32NextPower2Index (uint32_t v)
{
    if (pizUInt32IsPower2 (v)) {
        return pizUInt32LogBase2Index (v);
    } else {
        return pizUInt32LogBase2Index (v) + 1;
    }
}

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

long pizUInt64LogBase2Index (uint64_t v)
{
    if (!v) { return 0; }
    else {
    //
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v |= v >> 32;
    
    return (pizUtilsDeBruijn64[((uint64_t)((v - (v >> 1)) * 0x07edd5e59a4e28c2ULL)) >> 58]);
    //
    }
}

long pizUInt64NextPower2Index (uint64_t v)
{
    if (pizUInt64IsPower2 (v)) {
        return pizUInt64LogBase2Index (v);
    } else {
        return pizUInt64LogBase2Index (v) + 1;
    }
}

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
