#N canvas 318 41 540 604 12;
#X obj 36 456 +~;
#X obj 84 300 / 44.1;
#X obj 84 336 pack 0 30;
#N canvas 92 151 552 353 pulse 0;
#X obj 36 300 outlet~;
#N canvas 0 22 500 350 \$0-impulse 0;
#X array \$0-impulse 64 float 1;
#A 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
#X coords 0 1 63 0 250 175 1 0 0;
#X restore 264 36 graph \$0-impulse;
#X obj 264 240 nbx 5 40 0 8 0 1 empty empty empty 0 -7 0 10 #ffffff #000000 #000000 0 8;
#N canvas 438 393 260 248 impulse 0;
#X obj 24 24 inlet;
#X obj 24 192 s \$0-impulse;
#X obj 24 60 t f b;
#X msg 84 108 constant 0;
#X msg 84 144 \$1 1;
#X connect 0 0 2 0;
#X connect 2 0 4 0;
#X connect 2 1 3 0;
#X connect 3 0 1 0;
#X connect 4 0 1 0;
#X coords 0 0 1 1 250 175 0 0 0;
#X restore 264 300 pd impulse;
#X obj 36 264 tabplay~ \$0-impulse;
#X obj 36 60 metro 250;
#X obj 96 144 s \$0-bang;
#X obj 36 24 dspstatus;
#X obj 36 96 t b b;
#X connect 2 0 3 0;
#X connect 4 0 0 0;
#X connect 5 0 8 0;
#X connect 7 0 5 0;
#X connect 8 0 4 0;
#X connect 8 1 6 0;
#X coords 0 0 1 1 250 175 0 0 0;
#X restore 36 108 pd pulse;
#X obj 84 372 line~;
#X obj 12 12 cnv 15 250 45 empty empty empty 0 -7 0 10 #cccccc #000000;
#X obj -60 12 freeze;
#X text 24 24 delay (order);
#N canvas 212 40 771 520 more 0;
#X text 24 72 If you're writing to and reading from a delay line \, you have to get the write sorted before the read or else you'll never get less than a block's delay. This patch compares a "wrong" flanger with a "right" one:;
#X text 24 144 To get them to go off in the correct order \, put the delread~ and vd~ objects in subpatches. The audio connections between the subpatches force the "reader" to be sorted after the "writer". DSP sorting in Pd follows the hierarchy of subpatches.;
#X text 24 228 To hear the difference scroll the delay time between 0 and 100 samples. The patch at left doesn't let you get below 64 samples \, but the patch at right can go all the way down to one sample.;
#X text 36 324 You can use the same strategy to avoid picking up unwanted 64-sample delays in send~/receive~ and throw~/catch~ pairs.;
#X coords 0 0 1 1 250 175 0 0 0;
#X restore 432 312 pd more;
#X obj 84 168 delwrite~ \$0-delay 1000;
#X obj 84 408 vd~ \$0-delay;
#X obj 84 240 nbx 5 40 0 127 0 0 empty empty empty 0 -7 0 10 #ffffff #000000 #000000 0 127;
#N canvas 0 22 500 350 \$0-out 0;
#X array \$0-out 128 float 1;
#A 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
#X coords 0 1 127 0 250 175 1 0 0;
#X restore 252 396 graph \$0-out;
#X obj 60 504 r \$0-bang;
#X obj 36 552 tabwrite~ \$0-out;
#X text 12 72 The order of execution for delay lines matters.;
#X connect 0 0 14 0;
#X connect 1 0 2 0;
#X connect 2 0 4 0;
#X connect 3 0 0 0;
#X connect 3 0 9 0;
#X connect 4 0 10 0;
#X connect 10 0 0 1;
#X connect 11 0 1 0;
#X connect 13 0 14 0;
#X coords 0 0 1 1 250 175 0 0 0;
